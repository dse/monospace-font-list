#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;

use open qw(:locale);
use Encode::Locale;
use Encode qw(decode);
BEGIN {
    @ARGV = map { decode('locale', $_, Encode::FB_CROAK) } @ARGV;
}

use Data::Dumper qw(Dumper);
use File::Basename qw(basename);
use Sort::Naturally qw(nsort);
use YAML;
use URI;

my @urlless;

my $doc = YAML::Load(join('', <>));

print("# Monospace Font List\n\n");

print("DO NOT EDIT THIS FILE.  EDIT \`monospace-font-list.yaml\`.\n\n");

print("# Table of Contents\n\n");

foreach my $font (@{$doc->{fonts}}) {
    my $fontName = $font->{name};
    my $anchorName = uniqueAnchorName($fontName);
    printf("-   [%s](#%s)\n", $fontName, $anchorName);
    $font->{anchorName} = $anchorName;
}

print("\n");

foreach my $font (@{$doc->{fonts}}) {
    my $name = $font->{name};
    my $urls = delete $font->{urls};

    if (!$urls) {
        $urls = [];
    } elsif (ref $urls ne 'ARRAY') {
        $urls = [$urls];
    }
    foreach my $urlh (@$urls) {
        if (ref $urlh ne 'HASH') {
            $urlh = { url => $urlh };
        }
    }
    my $index = 0;
    foreach my $urlh (@$urls) {
        $urlh->{index} = ($index += 1);
        my $url = $urlh->{url};
        my $type = $urlh->{type};
        if (defined $type && $type eq 'official') {
            $urlh->{priority} = 2;
        } elsif (defined $type && $type eq 'via') {
            $urlh->{priority} = -1;
        } elsif (defined $url) {
            my $uri = URI->new($url);
            my $host;
            eval {
                $host = $uri->host;
            };
            if ($@) {
                my $error = $@;
                warn $name;
                die $error;
            }
            if ($host =~ m{(^|\.)github\.com$})             { $urlh->{priority} =  0.9; }
            elsif ($host =~ m{(^|\.)openfontlibrary\.org$}) { $urlh->{priority} =  0.8; }
            elsif ($host =~ m{(^|\.)fontlibrary\.org$})     { $urlh->{priority} =  0.8; }
            elsif ($host =~ m{(^|\.)typekit\.com$})         { $urlh->{priority} =  0.7; }
            elsif ($host =~ m{(^|\.)ffonts\.com$})          { $urlh->{priority} =  0.7; }
            elsif ($host =~ m{(^|\.)linotype\.com$})        { $urlh->{priority} =  0.7; }
            elsif ($host =~ m{(^|\.)myfonts\.com$})         { $urlh->{priority} =  0.7; }
            elsif ($host =~ m{(^|\.)fonts\.adobe\.com$})    { $urlh->{priority} =  0.7; }
            elsif ($host =~ m{(^|\.)fonts\.google\.com$})   { $urlh->{priority} =  0.7; }
            elsif ($host =~ m{(^|\.)google\.com$})          { $urlh->{priority} =  0.6; }
            elsif ($host =~ m{(^|\.)fontsquirrel\.com$})    { $urlh->{priority} =  0.5; }
            elsif ($host =~ m{(^|\.)dafont\.com$})          { $urlh->{priority} =  0.5; }
            elsif ($host =~ m{(^|\.)wikipedia\.org$})       { $urlh->{priority} =  0.1; }
            elsif (defined $type && $type eq 'original')    { $urlh->{priority} = -0.5; }
        }
        $urlh->{priority} //= 1;
    }

    @$urls = sort { $b->{priority} <=> $a->{priority} || $a->{index} <=> $b->{index} } @$urls;
    my $url = scalar @$urls ? $urls->[0]->{url} : undef;

    if (scalar @$urls) {
        shift @$urls;
        $font->{mainUrl} = $url;
    } elsif ($font->{'now known as'}) {
        # do nothing
    } else {
        push(@urlless, $name);
    }
    if (scalar @$urls) {
        $font->{urls} = $urls;
    }

}

foreach my $font (@{$doc->{fonts}}) {
    my $name = $font->{name};
    my $urls = $font->{urls};
    my $url = $font->{mainUrl};
    if (defined $url) {
        printf("## [%s](%s)\n\n", $name, $url);
    } else {
        printf("## %s\n\n", $name);
    }
    print toMarkdownImages($font);
    print toMarkdown($font);
}

if (scalar @urlless) {
    print "## Fonts not having URLs yet\n\n";
    foreach my $name (@urlless) {
        print "-   $name\n";
    }
    print "\n";
}

sub toMarkdownImages {
    my ($o) = @_;
    my $result = '';
    return $result unless $o;
    foreach my $key ('image', 'images') {
        my $data = $o->{$key};
        next unless $data;

        # force $data to be an array.
        if (!ref $data) {
            $data = [$data];
        }

        foreach my $item (@$data) {
            my $src;
            my $alt;
            if (ref $item eq 'HASH') {
                $src = $item->{src};
                $alt = $item->{alt} // $item->{title} // $o->{name};
            } elsif (!ref $item) { # assume string
                $src = $item;
                $alt = $o->{name};
            }
            $result .= sprintf("![%s](%s)\n\n", $alt, $src);
        }
    }
    return $result;
}

sub toMarkdown {
    my ($o, $level) = @_;
    $level //= 0;
    return '' unless defined $o;

    # shallow copy, so we can delete keys
    if (ref $o eq 'ARRAY') {
        $o = [ @$o ];
    } elsif (ref $o eq 'HASH') {
        $o = { %$o };
    }

    my $images;
    my $image;
    my $fontName;
    my $anchorName;
    my $mainUrl;

    if ($level == 0 && ref $o eq 'HASH') {
        $fontName = delete $o->{name};
        $anchorName = delete $o->{anchorName};
        $mainUrl = delete $o->{mainUrl};
        $images = delete $o->{images};
        $image = delete $o->{image};
    }

    my $result;

    if (ref $o eq 'ARRAY') {
        $result = '';
        foreach my $value (@$o) {
            my $r = toMarkdown($value, $level + 1);
            $r =~ s{^}{    }gms;
            substr($r, 0, 1) = '-';
            $r =~ s{\s+\z}{}s;
            $result .= $r . "\n\n";
        }
    } elsif (ref $o eq 'HASH') {
        $result = '';
        my @keys = nsort keys %$o;
        foreach my $key (@keys) {
            my $value = $o->{$key};
            if ($key eq 'urls') {
                my $r = "-   urls:\n";
                foreach my $urlh (@$value) {
                    $r .= "    -   ";
                    $r .= "via " if defined $urlh && defined $urlh->{type} && $urlh->{type} eq 'via';
                    $r .= '<' . $urlh->{url} . '>';
                    $r .= ' [' . $urlh->{priority} . ']' if defined $urlh->{priority};
                    $r .= ' [' . $urlh->{type} . ']' if defined $urlh->{type};
                    $r .= "\n";
                }
                $result .= $r . "\n";
                next;
            }
            next unless defined $value && $value =~ m{\S};

            my $r = toMarkdown($value, $level + 1);
            if ($r !~ m{\R.} && !(ref $value)) {
                # single line, simple string, neither an array nor a hash
                $r =~ s{^\s+}{};
                $r =~ s{\s+\z}{};
                $result .= "-   $key: $r\n\n";
            } else {
                $r =~ s{^}{    }gms;
                $r =~ s{\s+\z}{}s;
                $result .= "-   $key:\n\n";
                $result .= $r . "\n\n";
            }
        }
    } else {
        $result = $o;
        $result =~ s{\s*\z}{};
        $result .= "\n\n";
    }

    return $result;
}

# https://github.com/jch/html-pipeline/blob/master/lib/html/pipeline/toc_filter.rb
sub anchorName {
    my $name = shift;
    $name =~ s{[^\p{Word}\- ]}{}g;
    $name = lc($name);
    $name =~ s{ }{-}g;
    return $name;
}
sub uniqueAnchorName {
    state %anchorName;
    my $name = shift;
    my $anchorName = anchorName($name);
    my $uniq = $anchorName{$anchorName} // 0;
    $anchorName{$anchorName} += 1;
    if ($uniq) {
        $anchorName .= '-' . $uniq;
    }
    return $anchorName;
}
