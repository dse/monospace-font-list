#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;
use utf8;

#------------------------------------------------------------------------------
use File::Basename qw(basename);
our $PROGNAME = basename($0);

#------------------------------------------------------------------------------
use open IO => qw(:locale);
use Encode::Locale;
use Encode qw(decode);
BEGIN {
    @ARGV = map { decode('locale', $_, Encode::FB_CROAK) } @ARGV;
}

#------------------------------------------------------------------------------
our $verbose = 0;

#------------------------------------------------------------------------------
use Getopt::Long;
Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'v|verbose+' => \$verbose,
    'h|help'     => sub { usage(); exit(0); },
) or die("Type '$PROGNAME --help' for help.\n");

sub usage { print(<<"END"); }
usage:
    $PROGNAME [<option> ...] [<filename> ...]
options:
    -h, --help
    -v, --verbose
    ...
END

###############################################################################

use Data::Dumper qw(Dumper);
use File::Basename qw(basename);
use Sort::Naturally qw(nsort);
use YAML;
use URI;

printMarkdown();

###############################################################################

sub printMarkdown {

    my @urlless;

    my $doc = YAML::Load(join('', <>));

    print("# Monospace Font List\n\n");

    print("DO NOT EDIT THIS FILE.  EDIT \`monospace-font-list.yaml\`.\n\n");

    print("# Table of Contents\n\n");

    foreach my $font (@{$doc->{fonts}}) {
        my $fontName = $font->{name};
        if ($verbose) {
            printf STDERR ("-   %s\n", $fontName // '<undef>');
        }
        my $anchorName = uniqueAnchorName($fontName);
        printf("-   [%s](#%s)\n", $fontName, $anchorName);
        $font->{anchorName} = $anchorName;
    }

    print("\n");

    foreach my $font (@{$doc->{fonts}}) {
        my $name = $font->{name};
        my $urls = delete $font->{urls};

        if (!$urls) {
            $urls = [];
        } elsif (ref $urls ne 'ARRAY') {
            $urls = [$urls];
        }
        foreach my $urlh (@$urls) {
            if (ref $urlh ne 'HASH') {
                $urlh = { url => $urlh };
            }
        }
        my $index = 0;
        foreach my $urlh (@$urls) {
            $urlh->{index} = ($index += 1);
            my $url = $urlh->{url};
            my $type = $urlh->{type};
            if (defined $type && $type eq 'official') {
                $urlh->{priority} = 2;
            } elsif (defined $type && $type eq 'via') {
                $urlh->{priority} = -1;
            } elsif (defined $url) {
                my $uri = URI->new($url);
                my $host;
                eval {
                    $host = $uri->host;
                };
                if ($@) {
                    my $error = $@;
                    warn $name;
                    die $error;
                }
                if ($host =~ m{(^|\.)github\.com$}) {
                    $urlh->{priority} =  0.9;
                } elsif ($host =~ m{(^|\.)openfontlibrary\.org$}) {
                    $urlh->{priority} =  0.8;
                } elsif ($host =~ m{(^|\.)fontlibrary\.org$}) {
                    $urlh->{priority} =  0.8;
                } elsif ($host =~ m{(^|\.)typekit\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)ffonts\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)linotype\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)myfonts\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)fonts\.adobe\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)fonts\.google\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)google\.com$}) {
                    $urlh->{priority} =  0.6;
                } elsif ($host =~ m{(^|\.)fontsquirrel\.com$}) {
                    $urlh->{priority} =  0.5;
                } elsif ($host =~ m{(^|\.)dafont\.com$}) {
                    $urlh->{priority} =  0.5;
                } elsif ($host =~ m{(^|\.)wikipedia\.org$}) {
                    $urlh->{priority} =  0.1;
                } elsif (defined $type && $type eq 'original') {
                    $urlh->{priority} = -0.5;
                }
            }
            $urlh->{priority} //= 1;
        }

        @$urls = sort { $b->{priority} <=> $a->{priority} || $a->{index} <=> $b->{index} } @$urls;
        my $url = scalar @$urls ? $urls->[0]->{url} : undef;

        if (scalar @$urls) {
            shift @$urls;
            $font->{mainUrl} = $url;
        } elsif ($font->{'now known as'}) {
            # do nothing
        } else {
            push(@urlless, $name);
        }
        if (scalar @$urls) {
            $font->{urls} = $urls;
        }

    }

    foreach my $font (@{$doc->{fonts}}) {
        my $name = $font->{name};
        my $urls = $font->{urls};
        my $url = $font->{mainUrl};
        if (defined $url) {
            printf("## [%s](%s)\n\n", $name, $url);
        } else {
            printf("## %s\n\n", $name);
        }
        print toMarkdownImages($font);
        print toMarkdown($font);
    }

    if (scalar @urlless) {
        print "## Fonts not having URLs yet\n\n";
        foreach my $name (@urlless) {
            print "-   $name\n";
        }
        print "\n";
    }

}

sub toMarkdownImages {
    my ($o) = @_;
    my $result = '';
    return $result unless $o;
    foreach my $key ('image', 'images') {
        my $data = $o->{$key};
        next unless $data;

        # force $data to be an array.
        if (!ref $data) {
            $data = [$data];
        }

        foreach my $item (@$data) {
            my $src;
            my $alt;
            if (ref $item eq 'HASH') {
                $src = $item->{src};
                $alt = $item->{alt} // $item->{title} // $o->{name};
            } elsif (!ref $item) { # assume string
                $src = $item;
                $alt = $o->{name};
            }
            $result .= sprintf("![%s](%s)\n\n", $alt, $src);
        }
    }
    return $result;
}

sub toMarkdown {
    my ($o, $level) = @_;
    $level //= 0;
    return '' unless defined $o;

    # shallow copy, so we can delete keys
    if (ref $o eq 'ARRAY') {
        $o = [ @$o ];
    } elsif (ref $o eq 'HASH') {
        $o = { %$o };
    }

    my $images;
    my $image;
    my $fontName;
    my $anchorName;
    my $mainUrl;

    if ($level == 0 && ref $o eq 'HASH') {
        $fontName = delete $o->{name};
        $anchorName = delete $o->{anchorName};
        $mainUrl = delete $o->{mainUrl};
        $images = delete $o->{images};
        $image = delete $o->{image};
    }

    my $result;

    if (ref $o eq 'ARRAY') {
        $result = '';
        foreach my $value (@$o) {
            my $r = toMarkdown($value, $level + 1);
            $r =~ s{^}{    }gms;
            substr($r, 0, 1) = '-';
            $r =~ s{\s+\z}{}s;
            $result .= $r . "\n\n";
        }
    } elsif (ref $o eq 'HASH') {
        $result = '';
        my @keys = nsort keys %$o;
        foreach my $key (@keys) {
            my $value = $o->{$key};
            if ($key eq 'urls') {
                my $r = "-   urls:\n";
                foreach my $urlh (@$value) {
                    $r .= "    -   ";
                    $r .= "via " if defined $urlh && defined $urlh->{type} && $urlh->{type} eq 'via';
                    $r .= '<' . $urlh->{url} . '>';
                    $r .= ' [' . $urlh->{priority} . ']' if defined $urlh->{priority};
                    $r .= ' [' . $urlh->{type} . ']' if defined $urlh->{type};
                    $r .= "\n";
                }
                $result .= $r . "\n";
                next;
            }
            next unless defined $value && $value =~ m{\S};

            my $r = toMarkdown($value, $level + 1);
            if ($r !~ m{\R.} && !(ref $value)) {
                # single line, simple string, neither an array nor a hash
                $r =~ s{^\s+}{};
                $r =~ s{\s+\z}{};
                $result .= "-   $key: $r\n\n";
            } else {
                $r =~ s{^}{    }gms;
                $r =~ s{\s+\z}{}s;
                $result .= "-   $key:\n\n";
                $result .= $r . "\n\n";
            }
        }
    } else {
        $result = $o;
        $result =~ s{\s*\z}{};
        $result .= "\n\n";
    }

    return $result;
}

# https://github.com/jch/html-pipeline/blob/master/lib/html/pipeline/toc_filter.rb
sub anchorName {
    my $name = shift;
    $name =~ s{[^\p{Word}\- ]}{}g;
    $name = lc($name);
    $name =~ s{ }{-}g;
    return $name;
}
sub uniqueAnchorName {
    state %anchorName;
    my $name = shift;
    my $anchorName = anchorName($name);
    my $uniq = $anchorName{$anchorName} // 0;
    $anchorName{$anchorName} += 1;
    if ($uniq) {
        $anchorName .= '-' . $uniq;
    }
    return $anchorName;
}
