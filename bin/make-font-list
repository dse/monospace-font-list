#!/usr/bin/env perl
use warnings;
use strict;
use v5.10.0;
use utf8;

#------------------------------------------------------------------------------
use File::Basename qw(basename);
our $PROGNAME = basename($0);

#------------------------------------------------------------------------------
use open IO => qw(:locale);
use Encode::Locale;
use Encode qw(decode);
BEGIN {
    @ARGV = map { decode('locale', $_, Encode::FB_CROAK) } @ARGV;
}

#------------------------------------------------------------------------------
our $verbose = 0;

#------------------------------------------------------------------------------
use Getopt::Long;
Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'v|verbose+' => \$verbose,
    'h|help'     => sub { usage(); exit(0); },
) or die("Type '$PROGNAME --help' for help.\n");

sub usage { print(<<"END"); }
usage:
    $PROGNAME [<option> ...] [<filename> ...]
options:
    -h, --help
    -v, --verbose
    ...
END

###############################################################################

use Data::Dumper qw(Dumper);
use File::Basename qw(basename);
use Sort::Naturally qw(nsort);
use YAML;
use URI;
use Text::CSV;
use JSON;

my $json = JSON->new->allow_nonref->allow_unknown->allow_blessed;

my $doc = YAML::Load(join('', <>));
fixFontSites($doc);
setFontSiteDomains($doc);
categorizeFontSites($doc);
collectFontURLColumns($doc);
printCSV($doc);

###############################################################################
# urls: url domain name type
# fonts:
#     name, sites, tags, designer, updated, foundry, notes, description, license, cost

sub printCSV {
    my ($doc) = @_;

    my $fh = \*STDOUT;
    binmode($fh, ':encoding(utf8)');

    my $csv = Text::CSV->new({
        binary => 1,
        auto_diag => 1,
        decode_utf8 => 0,
    });

    $csv->say($fh, [
        'Name',
        'Designer',
        'Foundry',
        'License',
        'Cost',
        @{$doc->{fontURLColumns}},
        'Notes',
        'Description',
        'Tags',
        'Other',
    ]);

    foreach my $font (@{$doc->{fonts}}) {
        my $orig = $font;
        my $font = { %$orig };  # shallow clone
        my $name        = delete $font->{name}; # Name
        my $sites       = delete $font->{sites}; # Sites
        my $tags        = delete $font->{tags};  # Tags
        my $designer    = delete $font->{designer}; # Designer
        my $foundry     = delete $font->{foundry};  # Foundry
        my $notes       = delete $font->{notes};    # Notes
        my $description = delete $font->{description}; # Description
        my $license     = delete $font->{license}; # License
        my $cost        = delete $font->{cost};    # Cost
        my $updated     = delete $font->{updated};    # Cost
        my $urlsByType  = delete $font->{urlsByType};
        my $urlColumns  = delete $font->{urlColumns};
        my $images      = delete $font->{images};

        foreach my $x ($notes) {
            if (ref $x eq 'ARRAY') {
                $x = join("\n\n", map { ref $_ ? $json->encode($_) : $_ } @$x);
            }
        }
        foreach my $x ($tags) {
            if (ref $x eq 'ARRAY') {
                $x = join(", ", map { ref $_ ? $json->encode($_) : $_ } @$x);
            }
        }
        foreach my $x ($designer, $foundry, $license, $cost) {
            if (ref $x eq 'HASH') {
                $x = $json->encode($x);
            } elsif (ref $x eq 'ARRAY') {
                $x = $json->encode($x);
            }
        }

        my @fields;
        push(@fields, $name);
        push(@fields, $designer);
        push(@fields, $foundry);
        push(@fields, $license);
        push(@fields, $cost);
        foreach my $column (@{$doc->{fontURLColumns}}) {
            my @urls = eval { @{$urlsByType->{$column}} };
            if (scalar @urls) {
                push(@fields, join("\n", @urls));
            } else {
                push(@fields, '');
            }
        }
        push(@fields, $notes);
        push(@fields, $description);
        push(@fields, $tags);

        my $other = scalar keys %$font ? $json->encode($font) : '';

        push(@fields, $other);

        $csv->say($fh, [@fields]);
    }
}

sub collectFontURLColumns {
    my ($doc) = @_;
    $doc->{fontURLColumns} = {};
    foreach my $font (@{$doc->{fonts}}) {
        next if !defined $font->{sites};
        $font->{urlColumns} = {};
        foreach my $site (@{$font->{sites}}) {
            my $type = $site->{type} // 'otherURLs';
            push(@{$font->{urlColumns}->{$type}}, $site->{url});
            $doc->{fontURLColumns}->{$type} = 1;
        }
    }
    $doc->{fontURLColumns} = [keys %{$doc->{fontURLColumns}}];
    $doc->{fontURLColumns} = [
        'homepage',
        'wikipedia',
        'via',
        (
            sort { $a cmp $b } grep {
                1                   # dummy for easier editing
                  && $_ ne 'homepage'
                  && $_ ne 'wikipedia'
                  && $_ ne 'via'
                  && $_ ne 'otherURLs'
              } @{$doc->{fontURLColumns}}
        ),
        'otherURLs',
    ];
}

sub setFontSiteDomains {
    my ($doc) = @_;
    foreach my $font (@{$doc->{fonts}}) {
        next if !defined $font->{sites};
        foreach my $site (@{$font->{sites}}) {
            my $uri = URI->new($site->{url});
            my $host = eval { $uri->host };
            next if !defined $host;
            my $domain = $host;
            $domain =~ s{^www\.}{};
            $site->{domain} = $domain;
        }
    }
}

sub fixFontSites {
    my ($doc) = @_;
    foreach my $font (@{$doc->{fonts}}) {
        my $sites = $font->{sites};
        next if !defined $sites;
        if (ref $sites ne 'ARRAY') {
            $font->{sites} = $sites = [ $sites ];
        }
        $font->{sites} = $sites = [
            map { fixFontURL($_) } @{$font->{sites}}
        ];
    }
}

sub fixFontURL {
    my ($site) = @_;
    return { url => $site } if ref $site ne 'HASH';
    return $site;
}

sub categorizeFontSites {
    my ($doc) = @_;
    foreach my $font (@{$doc->{fonts}}) {
        next if !defined $font->{sites};
        $font->{urlsByType} = {};
        foreach my $site (@{$font->{sites}}) {
            my $uri = URI->new($site->{url});
            my $host = eval { $uri->host };
            next if !defined $host;
            if (!defined $site->{type}) {
                $site->{type} = 'github'       if $host =~ m{(^|\.)github\.com$};
                $site->{type} = 'fontlibrary'  if $host =~ m{(^|\.)openfontlibrary\.org$};
                $site->{type} = 'fontlibrary'  if $host =~ m{(^|\.)fontlibrary\.org$};
                $site->{type} = 'typekit'      if $host =~ m{(^|\.)typekit\.com$};
                $site->{type} = 'ffonts'       if $host =~ m{(^|\.)ffonts\.com$};
                $site->{type} = 'linotype'     if $host =~ m{(^|\.)linotype\.com$};
                $site->{type} = 'myfonts'      if $host =~ m{(^|\.)myfonts\.com$};
                $site->{type} = 'adobeFonts'   if $host =~ m{(^|\.)fonts\.adobe\.com$};
                $site->{type} = 'googleFonts'  if $host =~ m{(^|\.)fonts\.google\.com$};
                $site->{type} = 'fontsquirrel' if $host =~ m{(^|\.)fontsquirrel\.com$};
                $site->{type} = 'dafont'       if $host =~ m{(^|\.)dafont\.com$};
                $site->{type} = 'wikipedia'    if $host =~ m{(^|\.)wikipedia\.org$};
                $site->{typeKnown} = 1;
            } else {
                $site->{typeKnown} = 1 if $site->{type} eq 'homepage';
                $site->{typeKnown} = 1 if $site->{type} eq 'via';
            }
            if (!defined $site->{type}) {
                $site->{type} = 'otherURLs';
            } elsif (!$site->{typeKnown}) {
                $site->{type} = 'otherURLs';
            }
            push(@{$font->{urlsByType}->{$site->{type}}}, $site->{url});
        }
    }
}

###############################################################################

sub printMarkdown {

    my @urlless;

    my $doc = YAML::Load(join('', <>));

    print("# Monospace Font List\n\n");

    print("DO NOT EDIT THIS FILE.  EDIT \`monospace-font-list.yaml\`.\n\n");

    print("# Table of Contents\n\n");

    foreach my $font (@{$doc->{fonts}}) {
        my $fontName = $font->{name};
        if ($verbose) {
            printf STDERR ("-   %s\n", $fontName // '<undef>');
        }
        my $anchorName = uniqueAnchorName($fontName);
        printf("-   [%s](#%s)\n", $fontName, $anchorName);
        $font->{anchorName} = $anchorName;
    }

    print("\n");

    foreach my $font (@{$doc->{fonts}}) {
        my $name = $font->{name};
        my $sites = delete $font->{sites};

        if (!$sites) {
            $sites = [];
        } elsif (ref $sites ne 'ARRAY') {
            $sites = [$sites];
        }
        foreach my $urlh (@$sites) {
            if (ref $urlh ne 'HASH') {
                $urlh = { url => $urlh };
            }
        }
        my $index = 0;
        foreach my $urlh (@$sites) {
            $urlh->{index} = ($index += 1);
            my $url = $urlh->{url};
            my $type = $urlh->{type};
            if (defined $type && $type eq 'official') {
                $urlh->{priority} = 2;
            } elsif (defined $type && $type eq 'via') {
                $urlh->{priority} = -1;
            } elsif (defined $url) {
                my $uri = URI->new($url);
                my $host;
                eval {
                    $host = $uri->host;
                };
                if ($@) {
                    my $error = $@;
                    warn $name;
                    die $error;
                }
                if ($host =~ m{(^|\.)github\.com$}) {
                    $urlh->{priority} =  0.9;
                } elsif ($host =~ m{(^|\.)openfontlibrary\.org$}) {
                    $urlh->{priority} =  0.8;
                } elsif ($host =~ m{(^|\.)fontlibrary\.org$}) {
                    $urlh->{priority} =  0.8;
                } elsif ($host =~ m{(^|\.)typekit\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)ffonts\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)linotype\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)myfonts\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)fonts\.adobe\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)fonts\.google\.com$}) {
                    $urlh->{priority} =  0.7;
                } elsif ($host =~ m{(^|\.)google\.com$}) {
                    $urlh->{priority} =  0.6;
                } elsif ($host =~ m{(^|\.)fontsquirrel\.com$}) {
                    $urlh->{priority} =  0.5;
                } elsif ($host =~ m{(^|\.)dafont\.com$}) {
                    $urlh->{priority} =  0.5;
                } elsif ($host =~ m{(^|\.)wikipedia\.org$}) {
                    $urlh->{priority} =  0.1;
                } elsif (defined $type && $type eq 'original') {
                    $urlh->{priority} = -0.5;
                }
            }
            $urlh->{priority} //= 1;
        }

        @$sites = sort { $b->{priority} <=> $a->{priority} || $a->{index} <=> $b->{index} } @$sites;
        my $url = scalar @$sites ? $sites->[0]->{url} : undef;

        if (scalar @$sites) {
            shift @$sites;
            $font->{mainUrl} = $url;
        } elsif ($font->{'now known as'}) {
            # do nothing
        } else {
            push(@urlless, $name);
        }
        if (scalar @$sites) {
            $font->{sites} = $sites;
        }

    }

    foreach my $font (@{$doc->{fonts}}) {
        my $name = $font->{name};
        my $sites = $font->{sites};
        my $url = $font->{mainUrl};
        if (defined $url) {
            printf("## [%s](%s)\n\n", $name, $url);
        } else {
            printf("## %s\n\n", $name);
        }
        print toMarkdownImages($font);
        print toMarkdown($font);
    }

    if (scalar @urlless) {
        print "## Fonts not having Sites yet\n\n";
        foreach my $name (@urlless) {
            print "-   $name\n";
        }
        print "\n";
    }

}

sub toMarkdownImages {
    my ($o) = @_;
    my $result = '';
    return $result unless $o;
    foreach my $key ('image', 'images') {
        my $data = $o->{$key};
        next unless $data;

        # force $data to be an array.
        if (!ref $data) {
            $data = [$data];
        }

        foreach my $item (@$data) {
            my $src;
            my $alt;
            if (ref $item eq 'HASH') {
                $src = $item->{src};
                $alt = $item->{alt} // $item->{title} // $o->{name};
            } elsif (!ref $item) { # assume string
                $src = $item;
                $alt = $o->{name};
            }
            $result .= sprintf("![%s](%s)\n\n", $alt, $src);
        }
    }
    return $result;
}

sub toMarkdown {
    my ($o, $level) = @_;
    $level //= 0;
    return '' unless defined $o;

    # shallow copy, so we can delete keys
    if (ref $o eq 'ARRAY') {
        $o = [ @$o ];
    } elsif (ref $o eq 'HASH') {
        $o = { %$o };
    }

    my $images;
    my $image;
    my $fontName;
    my $anchorName;
    my $mainUrl;

    if ($level == 0 && ref $o eq 'HASH') {
        $fontName = delete $o->{name};
        $anchorName = delete $o->{anchorName};
        $mainUrl = delete $o->{mainUrl};
        $images = delete $o->{images};
        $image = delete $o->{image};
    }

    my $result;

    if (ref $o eq 'ARRAY') {
        $result = '';
        foreach my $value (@$o) {
            my $r = toMarkdown($value, $level + 1);
            $r =~ s{^}{    }gms;
            substr($r, 0, 1) = '-';
            $r =~ s{\s+\z}{}s;
            $result .= $r . "\n\n";
        }
    } elsif (ref $o eq 'HASH') {
        $result = '';
        my @keys = nsort keys %$o;
        foreach my $key (@keys) {
            my $value = $o->{$key};
            if ($key eq 'urls') {
                my $r = "-   urls:\n";
                foreach my $urlh (@$value) {
                    $r .= "    -   ";
                    $r .= "via " if defined $urlh && defined $urlh->{type} && $urlh->{type} eq 'via';
                    $r .= '<' . $urlh->{url} . '>';
                    $r .= ' [' . $urlh->{priority} . ']' if defined $urlh->{priority};
                    $r .= ' [' . $urlh->{type} . ']' if defined $urlh->{type};
                    $r .= "\n";
                }
                $result .= $r . "\n";
                next;
            }
            next unless defined $value && $value =~ m{\S};

            my $r = toMarkdown($value, $level + 1);
            if ($r !~ m{\R.} && !(ref $value)) {
                # single line, simple string, neither an array nor a hash
                $r =~ s{^\s+}{};
                $r =~ s{\s+\z}{};
                $result .= "-   $key: $r\n\n";
            } else {
                $r =~ s{^}{    }gms;
                $r =~ s{\s+\z}{}s;
                $result .= "-   $key:\n\n";
                $result .= $r . "\n\n";
            }
        }
    } else {
        $result = $o;
        $result =~ s{\s*\z}{};
        $result .= "\n\n";
    }

    return $result;
}

# https://github.com/jch/html-pipeline/blob/master/lib/html/pipeline/toc_filter.rb
sub anchorName {
    my $name = shift;
    $name =~ s{[^\p{Word}\- ]}{}g;
    $name = lc($name);
    $name =~ s{ }{-}g;
    return $name;
}
sub uniqueAnchorName {
    state %anchorName;
    my $name = shift;
    my $anchorName = anchorName($name);
    my $uniq = $anchorName{$anchorName} // 0;
    $anchorName{$anchorName} += 1;
    if ($uniq) {
        $anchorName .= '-' . $uniq;
    }
    return $anchorName;
}
